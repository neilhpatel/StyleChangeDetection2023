Block-oriented terminals were an interesting development. In exchange for adding a bit more circuitry to each terminal, the demands on a mainframe's time could be decreased. For example, consider an airline ticketing system. A booking agent wants to search for flights from JFK to SFO, deparing on 7/5/74. A character-oriented terminal would interrupt the mainframe each time a character was pressed, leading to expensive context switches as the mainframe had to service requests from each active terminal. A block-oriented terminal would be able to present a form with fillable fields for origin, destination, and date, which would only interrupt the mainframe when all data was submitted at once. IBM was able to take advantage of this to allow a single mainframe to serve a massive amount of terminals, but this meant that any interaction represented a relatively significant expense as compared to character-oriented terminals. (Consider the case of typing a paragraph of text and saving it. On a character-oriented terminal, the "save" command would be just one interrupt, after the interrupts for each letter. On a block-oriented terminal, the "save" command would be the only interrupt.).
So a smart terminal would send: "Hello world" as one block, eating up more bandwidth and processing power at once while a dumb terminal would send "H-e-l-l-o- -w-o-r-l-d--SAVE" as individual characters (and the command) interrupting the mainframe more frequently but not using as much processing power or bandwidth because each input is smaller and held in RAM?
Sorta. Bandwidth as you think of it today wasn't really a thing; getting into circuit-switching and multiplexing vs. packet-switching is waaaay too complex.